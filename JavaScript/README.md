# JavaScript

## 목차

- [Babel](#babel)
- [Browser Web API](#browser-web-api)
- [Closure](#closure)
- [Event Loop](#event-loop)
- [Intersection Observer](#intersection-observer)
- [JavaScript의 배열은 어떻게 동작할까?](#javascript의-배열은-어떻게-동작할까)
- [JS 동작 원리](#js-동작-원리)
- [Polyfill](#polyfill)
- [Promise](#promise)
- [Reflow](#Reflow)
- [TDZ(Temporal Dead Zone)](#tdztemporal-dead-zone)
- [렌더링 엔진 동작 과정](#렌더링-엔진-동작-과정)
- [호이스팅(Hoisting)](#호이스팅hoisting)

# JS 동작 원리

- 자바스크립트는 single thread로 동작하며(call stack이 하나), 비동기 callback을 사용하여 작업을 관리합니다. 즉, 한 번에 하나의 task만을 처리할 수 있다는 것인데, JavaScript에서는 ‘오래 걸리는 일’을 처리할 때 하나뿐인 call stack이 꽉 막혀, 작업이 비효율적으로 이루어지는 상황을 해결하기 위해 ‘비동기 콜백’을 사용하였습니다.
- 이 비동기 콜백, 비동기 동작을 효율적으로 처리하기 위해 활약하는 애들이 **Web API**, **Callback Queue**, **Event Loop**입니다.
- Web API는 작성된 코드에 갑자기 끼어드는 것을 할 수 없습니다. 어느 순간 갑자기 call stack에 함수를 집어넣는다든지, 이런 것을 할 수 없는 것입니다. 그래서 callback queue와 event loop를 이용하게 됩니다. Web API가 작동이 완료되면 callback을 callback queue에 넣습니다. 그리고 event loop가 call stack과 callback queue를 주시하면서, stack이 비어있으면, queue의 첫 번째 callback을 stack에 쌓아 효과적으로 실행할 수 있게 해줍니다.
- `setTimeout 0` 왜 해요? → 스택이 비어있을때까지 기다리게 하기 위해서.. (setTimeout은 Web API 기능인데, Web API는 작동이 완료되면 바로 call stack에 쌓이는 게 아니라, callback queue에 들어가 있다가, event loop가 주시하고 있던 stack이 비어있음을 알게 되면, event loop가 주시하고 있던 callback queue한테 있던 setTimeout의 callback을 stack에 넣어주게 되고, callback이 실행되는 것)
- forEach 함수는 callback 함수를 실행시키기는 하지만, 콜백이라고 할 수 있지만, 비동기적으로 실행하지는 않습니다. 이 때, `setTimeout 0` 을 이용해서 async forEach를 작성해 사용할 수도 있는 것입니다.
- stack에 코드가 있으면, 렌더링을 못합니다. 렌더도 하나의 callback처럼 행동하기 때문입니다. (그런데, 렌더는 callback에 비애 더 높은 우선순위를 가지긴 합니다.) 스택이 깨끗해진 후에야 렌더링을 합니다. 근데, 어떤 코드를 async를 통해 callback queue에 쌓아두게 하면.. 렌더가 끼어들 수 있는 기회를 줄 수 있게 됩니다.

# Browser Web API

- “오래 걸리는 일 따로 처리하기”
- browser web api는 브라우저 안에 C++로 구현된 thread 입니다(JS 엔진의 식구가 아님). 주로 DOM event, setTimeout 등 비동기 이벤트를 처리합니다.

# Event Loop

- event loop는 call stack이 비어있는지 주기적으로 확인하고, callback queue에서 callabck function을 가져와서, JS 코드가 실행될 수 있도록 돕는 역할을 합니다.
- `tick` : event loop가 반복적으로 call stack이 비어있는지 확인하는 것

# JavaScript의 배열은 어떻게 동작할까?

- JavaScript의 배열은 내부적으로 동적 배열(dynamic array)와 유사한 구현을 사용합니다. 동적 배열을 고정 크기 배열과 달리, 메모리 할당을 유연하게 조절할 수 있습니다. JavaScript에서 배열의 크기를 동적으로 조절하면서 요소를 추가하거나 삭제할 때, 시스템은 일반적으로 기존 배열의 크기보다 큰 새로운 배열을 할당하고, 기존 요소들을 복사합니다. 이 과정에서 추가적인 메모리 할당 및 복사가 발생할 수 있습니다.
- 자바스크립트의 배열은 엄밀히 말해 일반적 의미의 배열은 아닙니다. 배열의 요소를 위한 각각의 메모리 공간이 동일한 크기를 가지지 않아도 되며, 연속적으로 이어져 있지 않을 수도 있습니다. 자바스크립트의 배열은 “일반적인 배열의 동작을 흉내낸 특수한 객체”입니다.
- 즉, 자바스크립트 배열은 인덱스로 배열 요소에 접근하는 경우에는, 일반적인 배열보다 느리지만, 특정 요소를 탐색하거나, 삽입하거나, 삭제하는 경우에는 일반적인 배열보다 빠릅니다. 자바스크립트 배열에서는 요소 탐색, 삽입, 삭제하는 경우의 성능을 선택한 것이라고 이해했습니다.

# Promise

- Promise는 프로미스가 생성된 시점에는 알려지지 않은 상태일 수도 있는 값을 위한 대리자로, 비동기 연산이 종료된 이후에 결과 값이나 실패 사유 등을 처리하기 위한 처리기를 연결할 수 있습니다. 프로미스를 사용하면 비동기 메서드에서 마치 동기 메서드처럼 값을 반환할 수 있습니다. 다만, 최종 결과를 ‘return’하는 것이 아니고, 미래의 어떤 시점에서 시점에 따른 결과를 제공하겠다는 `Promise`를 반환하는 것이 특징입니다.
- `then()` 메서드는 최대 두 개의 인수를 받습니다. 첫 번째 인수는 프로미스의 이행된 경우에 대한 콜백 함수이고, 두 번째 인수는 거부된 경우에 대한 콜백 함수입니다. then은 새로 생성된 프로미스 객체를 반환하며, 연쇄적으로 사용할 수도 있습니다.

# 렌더링 엔진 동작 과정

- 먼저, ‘파싱 단계’에서 DOM tree와 CSSOM tree를 만듭니다.
- 다음으로, DOM과 CSSOM을 묶어서 Render tree를 만듭니다.
- 렌더 트리에서 각 노드가 어디에 어떻게 그려져야 하는 지 모양을 계산하는데, 이것이 ‘레이아웃’ 단계입니다.
- 계산이 완료되면, 계산한대로 화면에 elements를 배치합니다. 이것을 ‘페인팅한다’고 합니다.

# Closure

- 클로저는 자바스크립트 고유의 개념은 아닙니다. 클로저는 함수를 객체로 취급하는 함수형 프로그래밍 언어에서 사용되는 중요한 특성입니다.
- 클로저는 **내부함수**에서 **외부함수**의 범위에 대한 접근을 제공하는, 함수와 그 함수(내부함수)가 선언됐을 때의 Lexical 환경과의 조합입니다. JS에서 클로저는 함수 생성 시 함께 생성됩니다.
- 즉, 클로저는 반환된 내부함수가 자신이 선언되었을 때의 ‘Lexical 환경인 스코프’를 기억하여, 자신이 선언됐을 때의 환경 밖에서 호출되더라도, 그 환경에 접근할 수 있는 함수를 말합니다.
- 더 간단히 하자면, 클로저는 “자신이 생성될 때의 환경을 기억하는 함수”라고 할 수 있습니다.
- 클로저라는 이름은 자유변수(free variable)에 함수가 닫혀있다(closed)라는 의미로, 의역하면 “자유변수에 엮여있는 함수”라는 것으로 이해할 수 있습니다.

# Polyfill

- 변경된 표준을 준수할 수 있게 기존 함수의 동작 방식을 수정하거나, 새롭게 구현한 함수의 스크립트를 “폴리필”이라고 합니다. 말 그대로, 구현이 누락된 새로운 기능을 메꿔주는(fill) 역할을 한다고 보면 됩니다.
- 즉, 최신 자바스크립트의 기능을 구식 자바스크립트 코드로 똑같이 구현한 코드를 말합니다.

# Babel

- Babel은 트렌스파일러입니다. 모던 자바스크립트에서 쓰이는 최신 문법을 쓸 수 없어, 구 표준을 준수하는 문법으로 바꿔주는 역할을 합니다.
- (Polyfill과의 차이점) Polyfill은 변경된 표준을 준수할 수 있도록, 기존 함수의 동작 방식을 수정하거나 새롭게 구현하여 누락된 새로운 기능을 메꿔주는 역할을 합니다. (즉, 기존 코드가 구 표준을 준수하는 코드로 변경되는 것) 예를 들어, ES6에서 새롭게 등장한 Promise와 같이 ES5에서 변환할 수 있는 대상이 없는 경우에는 에러가 발생하기 때문에, Polyfill이 사용됩니다.

# 호이스팅(Hoisting)

- 호이스팅이란, 인터프리터가 변수와 함수의 메모리 공간을 선언 전에 미리 할당하는 것을 의미합니다. 코드가 실행하기 전 변수선언/함수선언에 해당하는 코드가 해당 스코프의 최상단으로 끌어 올려진 것 같은 현상이라고 이해하였습니다. 이처럼, 자바스크립트 함수는 실행되기 전에 함수 안에 필요한 변수값들을 모두 모아서 유효 범위의 최상단에 선언합니다.

# TDZ(Temporal Dead Zone)

- Temporal Dead Zone은 직역하자면 '일시적인 사각지대'로, '변수의 선언과, 변수의 초기화 사이, 변수에 접근날 수 없는 지점'을 말합니다. 즉, 초기화되지 않은 변수가 있는 곳을 TDZ라고 하는 것입니다.
- 자바스크립트에서 변수는 기본적으로 '선언 단계', '초기화 단계', '할당 단계'를 거쳐 생성이 됩니다. 가령, let과 const는 선언과 초기화를 따로 진행합니다. 선언 시 TDZ가 있다는 것인데, 이 경우 호이스팅은 되지만 참조할 메모리가 없어, 참조하려고 하면 참조 오류가 발생하게 됩니다. TDZ에 대한 개념을 이해하고 있다면, let과 const 등 TDZ가 존재하는 선언부를 사용할 때, 참조 오류 발생 등 여러 부작용을 방지할 수 있을 것입니다.

# Reflow

- reflow는 레이아웃 계산을 다시 하는 것으로, reflow가 발생하면 repaint는 필연적으로 발생합니다. reflow는 HTML 요소들의 위치와 크기를 다시 계산해야 하기 때문에, repaint에 비해 시간이 오래 걸립니다. 변경하려는 위치와 크기뿐만 아니라, 연관된 다른 요소들의 위치와 크기까지 재계산해야 하기 때문입니다. 따라서, **개발자는 reflow가 자주 발생하도록 하는 코드는 지양해야 합니다**.
- (repaint: 재결합 된 렌더 트리를 기반으로 다시 화면에 paint하는 것)
- reflow를 최소화 하기 위한 방법으로는 이런 방법을 생각할 수 있습니다. '가급적 레이아웃 변경'을 피하는 것입니다. 가령, width와 height 등의 기하학적인 속성의 변경은 reflow가 발생하게 됩니다. 따라서 꼭 필요한 경우가 아니면 width, height 등 기하학적 속성의 변경은 피하는 것이 좋습니다. 피하기 어렵다면, `transform`를 사용하거나, `visibility, display`보다는 `opacity`를 사용하는 것이 성능 개선에 더욱 도움이 된다고 합니다.

# Intersection Observer API

- Intersection Observer API는 직역하자면 '교차 관찰자 API'로, '브라우저 뷰포트'와 원하는 '요소'의 **교차점**을 관찰하며, 요소가 뷰포트에 포함되는지 아닌지 구별하는 기능을 제공합니다. 즉, 특정 요소가 사용자 화면에 보이는지 여부를 판단하는 것입니다. 이 intersectin observer는 **비동기적**으로 실행되기 때문에, 메인 스레드에 영향을 주지 않으면서 요소들의 변경사항들을 관찰할 수 있습니다. (nice ^^) 따라서, 이를 이용하면 `scroll` 등 이벤트 기반의 요소 관찰에서 발생하는 렌더링 성능이나 이벤트 연속 호출의 문제를 해결할 수 있습니다. 또한, `IntersectionObserverEntry`의 속성을 활용하여 요소들의 위치를 알 수 있기 때문에, **리플로우 현상을 방지**할 수 있습니다.
- lazy loading, infinite-scroll 구현 등에 intersection observer를 사용할 수 있습니다.