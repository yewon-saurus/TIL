# Docker

## 목차

- [Docker 관련 bash shell 명령어](#docker-관련-bash-shell-명령어)
- [Dockr 명령어 요약](#dockr-명령어-요약)
- [docker run](#docker-run)
- [docker start](#docker-start)
- [TTY(텔레타입)](#tty텔레타입)
- [docker 사용 시나리오](#docker-사용-시나리오)
- [Dockerfile](#dockerfile)
- [Docker 레이어](#docker-레이어)

# Docker 관련 bash shell 명령어

```shell
sudo service docker status # Docker가 서비스 실행 중인지 확인
sudo service docker start # Docker 서비스를 수동으로 시작
sudo service docker restart
```

# Dockr 명령어 요약

```shell
docker search <이미지 이름> # 이미지 검색
docker images # 이미지 목록 확인
docker ps # 실행 중인 컨테이너 목록 확인
docker ps -a # 모든 컨테이너 목록 확인
docker rm <컨테이너 ID or name> # 컨테이너 삭제

docker stop <컨테이너 ID or name> # 컨테이너 중지
docker start <컨테이너 ID or name>
docker restart <컨테이너 ID or name>
docker pause <컨테이너 ID or name>
docker unpause <컨테이너 ID or name>

docker exec -it <컨테이너 ID or name> bash # 컨테이너의 터미널에 접속
# `-i`: 인터렉티브 모드 활성화(표준 입력을 유지하여 터미널에 입력할 수 있다.)
# `-t`: TTY(텔레타입) 모드 활성화(터미널의 tty를 할당하여 터미널로 사용할 수 있다.)
# `/bin/bash`: 터미널 접속에 bash 쉘 사용
```

# docker run

- `docker run` 명령어는 Docker 컨테이너를 생성하고 시작하는 데 사용됩니다. 이 명령어는 Docker 이미지에서 컨테이너를 처음부터 시작할 때 사용됩니다. 필요한 경우, Docker Hub에서 이미지를 다운로드 하는 것부터 시작해, 지정된 이미지에서 새로운 컨테이너를 생성하고, 시작합니다. 포트 매핑, 환경 변수, 볼륨 마운트 등 다양한 옵션을 적용할 수 있습니다.

```bash
docker run -d --name aivle -v $(pwd):/app -p 8000:8000 django:latest
```

- `docker run`: 새로운 Docker 컨테이너를 생성하고 실행하는 명령어입니다.
- `-d`: 컨테이너를 데몬 모드로 실행합니다. 이 옵션을 사용하면 컨테이너가 백그라운드에서 실행되며, 터미널을 점유하지 않습니다.
- `--name aivle`: 생성되는 컨테이너의 이름을 `aivle`로 지정합니다. 이름을 지정하면 <컨테이너 ID> 대신 이름으로 컨테이너를 참조할 수 있습니다.
- ⭐ `-v $(pwd):/app`: 볼륨 마운트 옵션입니다. 호스트의 현재 작업 디텍토리(`$(pwd)`)를 컨테이너의 `/app` 디렉토리에 마운트합니다.
- `-p 8000:8000`: 포트 포워딩 옵션입니다. 호스트의 포트 8000을 컨테이너의 포트 8000에 매핑합니다. 이 옵션을 사용하면 호스트의 `http://localhost:8000`에 접속 시 컨테이너 내부에서 실행 중인 웹 서버에 접근할 수 있는 것입니다.
- `django:latest`: 사용할 Docker 이미지 이름과 태그를 지정합니다. 여기서는 `django` 이미지를 사용하며, `latest` 태그는 최신 버전을 의미합니다.

음.. 그런데, `-d`만 쓰고 `-it`를 제외하고 명령어를 실행했더니, container가 실행되자마자 직후 exited 되어 버렸습니다. 여기서 파악한 `-d`와 `-it`를 함께 사용하는 이유는 다음과 같습니다.
1. 디버깅 및 테스트: 컨테이너를 백그라운드에서 실행하면서도 필요할 때 터미널 세션을 열어 디버깅하거나 테스트할 수 있습니다.
2. ⭐ 컨테이너 내에서 유지되는 셸: 컨테이너가 백그라운드에서 실행되면서도, `bash`와 같은 셸을 실행할 수 있습니다. **이는 컨테이너가 종료되지 않도록 유지할 수 있게 합니다**.

```bash
docker run -d --name aivle -v $(pwd):/app -p 8000:8000 -it ehdnjs0804/aivle-4th-team19-liquest-server bash
```

>의문: `docker run`에서도 `-it` 옵션을 붙여 사용하기도 하나요?

- 그렇다고 합니다. 다음과 같은 예시를 보면,

```bash
docker run -it --name my-container ubuntu /bin/bash
```

- 위 명령어는 `ubuntu` 이미지를 기반으로 `my-container`라는 이름의 컨테이너를 생성하고, 컨테이너 내부에서 `/bin/bash` 셸을 실행합니다. 이 경우 `-it` 옵션 덕분에 사용자는 **터미널을 통해 컨테이너와 상호작용할 수 있습니다**.
- 때로는 `-d`(detached) 옵션과 `-it` 옵션을 함께 사용하고 싶다는 생각이 들 수도 있는데, 이 옵션은 **상호 베타적인 경우가 많습니다**. `-d`는 컨테이너를 백그라운드에서 실행하는 데 사용되고, `-it`는 터미널 인터페이스를 활성화하는 데 사용되므로 동시에 사용할 실질적인 이유는 없습니다.
- 다만, 특정 상황에서는 컨테이너를 백그라운드에서 실행한 후, 나중에 `docker exec -it` 명령어를 사용하여 터미널에 접속할 수 있습니다.

# docker start

- `docker start` 명령어는 이미 생성되어 있던 (하지만 중단된) 컨테이너를 다시 시작하는 데 사용됩니다. 이 명령어는 새로운 컨테이너를 생성하지는 않으며, 기존의 컨테이너를 다시 실행합니다. 주로 `docker run`으로 생성했던 컨테이너를 중지한 후 다시 시작할 때 사용합니다.

# TTY(텔레타입)
- '텔레타입'은 "컴퓨터와 사용자 간 상호작용을 가능하게 한 초기 장치"를 의미합니다. (터미널 인터페이스의 초기 형태)
- 현대적 의미로는, "소프트웨어적으로 구현된 가상 터미널"을 의미합니다.
- 즉, "가상 터미널을 활성화하여 사용자와 컨테이너 간 상호작용을 가능하게 한다"고 이해하면 되겠습니다.

# docker 사용 시나리오

>시나리오 1: Docker Container 내에서 Django 애플리케이션 실행

```bash
python3 manage.py runserver 0.0.0.0:8000
```

- `0.0.0.0`: 이 IP 주소는 **모든 네트워크 인터페이스를 의미**합니다. 즉, Django 웹 서버가 **컨테이너 내부의 모든 네트워크 인터페이스에서 수신 대기하도록** 설정합니다. 컨테이너 내부에서 실행되고 있는 Django 애플리케이션이 Docker 네트워크를 통해 외부에서 접근 가능하게 됩니다. `0.0.0.0`을 사용하면, localhost 뿐만 아니라 다른 머신이나 컨테이너에서도 접속할 수 있습니다.
- `:8000`: `8000`은 서버가 바인딩 할 포트 번호입니다. Django 애플리케이션이 요청을 수신하고 응답을 보내기 위해 사용할 포트 번호를 지정한 것입니다. 기본적으로 Django의 개발 서버는 포트 8000에서 실행됩니다.
- 컨테이너 내에서 `0.0.0.0:8000`을 사용하여 Django 서버를 실행하면:
    - 1. 내부 네트워크 접근: Django 서버는 컨테이너의 모든 네트워크 인터페이스에서 요청을 수신 대기합니다. 이 설정으로 인해 컨테이너가 속한 Docker 네트워크 내의 다른 컨테이너들이 Django 애플리케이션에 접근할 수 있습니다.
    - 2. 외부 네트워크 접근: Docker 호스트 머신의 포트를 컨테이너의 포트와 매핑하는 경우, 외부에서 접근할 수 있다고 했습니다. 예를 들어, `docker run -p 8000:8000` 명령어를 사용하면, Docker 호스트의 포트 8000을 컨테이너의 포트 8000에 매핑하는 것이라고 설명했습니다. 이렇게 하면, 호스트 머신의 `http://localhost:8000` 주소로 외부에서 Django 애플리케이션에 접근할 수 있게 되는 것입니다.
- 즉, 이 설정을 통해 컨테이너 내부와 외부에서 Django 애플리케이션에 접근할 수 있습니다.

# Dockerfile

Dockerfilw은 Docker Image를 생성하기 위한 스크립트(즉, 설정파일)입니다. Dockerfile을 읽을 줄 안다는 것은 해당 이미지가 어떻게 구성되어 있는지 알 수 있다는 의미입니다.

또한, Dockerfile을 작성하는 것으로 다음과 같은 효과를 기대할 수 있습니다. 첫째, "이미지가 어떻게 만들어졌는지 기록된다". 어떤 애플리케이션을 실행할 수 있는 image가 설치되기 위한 과정은 어떠한지, 어떤 과정을 수정해야 하는지 등을 알아야 하는 경우가 있는데, Dockerfile이 자동화 된 스크립트 형태이기 때문에 이를 파악하기에 용이합니다. 둘째, "배포에 용이하다". 어떤 image를 배포하는 상황에서, 몇 GB나 되는 이미지 파일 자체를 배포하기보다는 그 이미지를 만들 수 있는 스크립트를 배포한다면 매우 편리할 것입니다. 셋째, "컨테이너(또는 이미지)가 특정 행동을 수행하도록 한다". 컨테이너 환경에서 애플리케이션을 개발하다 보면, 특정한 행동을 취하도록 하는 컨테이너(또는 이미지)를 만들어야 할 때가 있습니다.

```dockerfile
FROM alpine

# image가 올라갔을 때 수행되는 명령어들
RUN \
    apt-get update && \
    apt-get install -y apache2

# apache2가 기본적으로 80포트를 사용하기 때문에, expose를 이용해 apache server로 접근이 가능하도록 처리
EXPOSE 80

# 컨테이너가 생성 된 이후에 내부의 apache 서버는 항상 실행중인 상태로 만들어 준 것
# apachectl을 daemon 상태로 돌아가도록 했다
CMD ["apachectl", "-D", "FOREGROUND"]
```

- `FROM`: 어느 이미지에서 시작할 것인지 '베이스 이미지'를 설정합니다.
- `RUN`: 새로운 레이어에서 명령어를 실행하고, 새로운 이미지를 생성합니다.
    - RUN 명령을 실행할 때마다 레이어가 생성되고 캐시됩니다.
    - 따라서, RUN 명령을 따로 실행하면 `apt-get update`는 다시 실행하지 않아서 최신 패키지를 설치할 수 없는 것!!
    - 위 처럼 RUN 명령 하나에서 한꺼번에 실행해주도록 처리하면 됩니다다.
- `EXPOSE`: Dockerfile의 빌드로 생성된 이미지에서 열어줄 포트를 의미한다. 호스트 머신과 컨테이너의 포트 매핑 시 사용됩니다. (컨테이너 생성 시 `-p` 옵션의 컨테이너 포트 값으로 EXPOSE 값을 적어야 합니다.)
- `CMD`/`ENTRYPOINT`: 컨테이너를 생성 및 실행할 때 실행할 명령어를 지정할 수 있습니다. 보통 컨테이너 내부에서 항상 돌아가야 하는 서버를 띄울 때 사용합니다.
    - `CMD`는 컨테이너 생성 시에만 실행, `ENTRYPOINT`는 컨테이너 시작할 때마다 실행된다는 차이가 있습니다.

>etc

- ⭐ Dockerfile에서 명령어 하나가 실패하더라도, Docker build를 중단하지 않고 다음 명령을 계속 실행하도록 설정하기 위해 `|| ture` 구문을 사용할 수 있습니다. 이는 쉘에서 제공하는 구문으로, 해당 줄의 명령어가 실패하더라도 뒤에 있는 `true` 명령어가 실행되어 종료 상태가 0(성공)으로 설정됩니다. 다만, 오류를 무시하게 되는 위험이 있고, 이것이 나중에 예상치 못한 오류까지 발생시킬 수 있으며, 문제를 디버깅하기 어려울 수 있습니다. 쉘에서 조건부 논리 `&&`, `||`를 사용해 특정 오류에 대해 더 세밀하게 제어할 수 있다는 것을 알게 되었습니다.

# Docker 레이어

- Dockerfile에서 여러 명령어를 각 `RUN` 명령어로 나누어 실행할 때, 각 명령어가 서로 다른 레이어에서 실행되기 때문에 문제가 발생할 수 있습니다. Docker는 각 `RUN` 명령어를 실행할 때마다 새로운 레이어를 실행합니다. 이 레이어는 이전 명령어의 상태를 기반으로 하기는 하지만, **독립적으로 저장되고 관리됩니다**.
- 즉, 각 `RUN` 명령어는 독립적으로 실행되며, **이전 명령어의 변경 사항은 현재 명령어의 실행 컨텍스트에 직접적으로 반영되지 않습니다**. 예를 들어, `cd`와 같은 상태 변경은 다음 `RUN` 명령어에서 유지되지 않는 것입니다. 따라서 이를 방지하기 위해, 모든 명령어를 하나의 `RUN` 명령어로 결합하여 실행 컨텍스트를 유지하는 것이 좋습니다. (이 때, 중간 파일을 제거하는 과정도 포함해 이미지 크기를 최적화 할 수 있습니다.)