# 세그먼트 트리

구간합, 합배열

index tree 에 포함되는 파트 인가봐요

얘네는 이진트리 형태 랍니다

데이터를 업데이트보다 합배열을 두고 구하는게 빠르다는 것

`구간합`, `최대 / 최소` 같은거 할 수 있어요

1. 트리 초기화

```
2^k >= N 을 만족하는 k의 최솟값을 구하고

2^k * 2 -> 트리 배열로..
```

ex)

단말 노드의 갯수 N = 8 이면

2^3 >= 8

k = 3

트리 배열은 2^3 * 2 = 16

으로 정의 해야 한답니다.

리프 노드의 시작 위치는.. 2^k를 시작 인덱스로 하면 된답니다.

이게 무슨 말일까요? 자세히 봐봅시다..

2. 질의 값 구하기

주어진 질의 인덱스를 세그먼트 트리의 리프 노드에 해당하는 인덱스로 변경

무슨 말이죠?

```
index = (주어진 질의 index) + 2^k - 1
```

ex)

k = 3 이라면,

만약에 제가 index가 1 ~ 3인 애들에 질의를 날리고 싶어요

1 + 2^3 - 1 = 8

3 + 2^3 - 1 = 10

트리 배열의 8 ~ 11에 대한 질의로 바뀌어요

- (1) start_index % 2 == 1; 해당 노드 선택

- (2) end_index % 2 == 0; 해당 노드 선택

- (3) start_index의 depth 변경: start_index = (start_index + 1) / 2 연산 수행

- (4) end_index의 depth 변경: end_index = (end_index - 1) / 2 연산 수행

- (5) (1)~(4) 를 반복하다, end_index < start_index 가 되면 종료 // 크로스 되면..

```java
class SegmentTree {
    long tree[]; // 각 원소가 담길 트리
    int treeSize; // 트리의 크기

    public SegmentTree(int arrSize) {
        // 트리 높이 구하기
        int h = (int) Math.ceil(Math.log(arrSize) / Math.log(2));

        this.treeSize = (int) Math.pow(2, h+1); // 높이를 이용한 배열 사이즈 구하기

        tree = new long[treeSize];
    }

    // arr = 원소배열, node = 현재노드, start = 현재구간 배열 시작, start = 현재구간 배열 끝
    public long init(long[] arr, int node, int start, int end) {
        // 배열의 시작과 끝이 같다면 leaf 노드이므로
        // 원소 배열 값 그대로 넣기
        if (start == end) {
            return tree[node] = arr[start];
        }

        // leaf 노드가 아니면, 자식노드 합 담기
        return tree[node] = init(arr, node*2, start, (start + end)/2) + init(arr, node*2+1, (start + end)/2+1, end);
    }
}
```

(+) ㅋㅋ tree의 depth는 0부터 시작이더군요? 루트 노드는 depth가 0인 거예요
