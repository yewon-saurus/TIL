# React

## 목차

- [CDD(Component Driven Development)](#cddcomponent-driven-development)
- [Client Side Rendering, Server Side Rendering](#client-side-rendering-server-side-rendering)
- [Custom Hook](#custom-hook)
- [Next.js](#nextjs)
- [Portal](#portal)
- [React의 장점](#react의-장점)
- [Redux](#redux)
- [Single Page Application (SPA)](#single-page-application-spa)
- [SPA와 CSR은 같은 말일까?](#spa와-csr은-같은-말일까)
- [State Management](#state-management)
- [useCallback](#usecallback)
- [컴포넌트 생명주기](#컴포넌트-생명주기)

# React의 장점

- Virtual DOM이라는 개념이 있습니다. Virtual DOM은 실제 DOM의 복제본으로, 변화가 감지된 부분만 Virtual DOM에서 수정하게 되고, React는 Virtual DOM과 실제 DOM 사이의 차이점을 찾아내서, 그 차이점만을 실제 DOM에 반영하려고 합니다. 즉, 이로써 불필요한 화면 갱신을 최소화하게 되니까, 성능이 향상된다는 것입니다.
- 그런데, 이런 기술적이고 이론적인 얘기보다는 저에게 와닿고 공감되는 ‘장점’은 따로 있었습니다.
- JSX 구문으로, JavaScript 코드에서 HTML 구문을 직접 활용 가능하다는 점이 좋았습니다. 간결하고 가독성이 뛰어나며 포괄적인 코드를 작성할 수 있어 개발 워크플로우나 유지보수 하기에 (뭐랄까) 최적화 되어있다 느꼈습니다.
- 또, “별도의 컴포넌트를 만들고 재사용”하는 데 편리하다고 느꼈습니다.
- 즉, 정리하자면 React의 장점은 “DOM의 효율 문제를 해결한다” 보다는 “개발자가 개발하는 데 편의를 제공한다”는 점이었습니다.

# State Management

- React에서의 ‘상태’란 컴포넌트 내부에서 관리되는 어떤 데이터를 말합니다. 이 데이터의 변화에 따라 컴포넌트는 다시 렌더링되며, 화면이 업데이트 됩니다.
- 가장 기본적인 상태 관리 방법은 `setState` 메서드를 사용하는 것입니다. 그런데, 대규모 애플리케이션에서는 보다 효율적이고 유지보수가 쉬운 상태 관리가 필요한데, 이를 위해 쓰는 것이 Redux, ContextAPI 등 라이브러리를 사용할 수 있습니다.
- props를 통해 상태를 전달하게 되면, 코드의 가독성이 떨어지고 유지보수가 힘들어지게 될 수 있습니다. 또, 상태 업데이트 시 props 전달 과정에서 불필요하게 관여된 컴포넌트들 또한 리렌더링이 발생하게 되어 비효율적인 동작을 할 수도 있게 됩니다. (props drilling 문제) 하지만, 상태들을 하나의 공간에 모아두고 ‘전역 상태’로 관리하게 된다면, 좀 더 예측 가능하게 상태 관리를 할 수 있습니다.
- 가령, Redux를 사용하게 된다면, 애플리케이션의 전역 상태를 하나의 store에 저장하고(단일 store 패턴), action을 dispatch해서 상태를 변경합니다. 그럼, 이 상태를 구독하고 있던 컴포넌트들은, 상태가 변경될 때마다 새로 렌더링을 하게 되고, 화면이 업데이트 되는 것입니다. 이렇게 redux를 이용하면, 여러 컴포넌트 간 상태 공유와 관리를 용이하게 해줍니다.

# Redux

- Redux는 JavaScript의 상태 관리 라이브러리입니다. Redux는 ‘단일 스토어 패턴’을 따르며, 애플리케이션의 전역 상태를 하나의 JavaScript 객체로 관리합니다.
- Store ⇒ 애플리케이션의 상태를 저장하는 객체입니다. Redux에서 사용하는 단일 스토어가 이것입니다. 전역 상태가 이 스토어에 저장되는 것입니다.
- Actions ⇒ 상태를 변화시키는 이벤트를 말합니다. 주로 JavaScript 객체로 표현되며, `type` 필드를 포함합니다.
- Reducers ⇒ 이전 상태와 액션을 받아서 다음 상태를 반환하는 순수 함수입니다. 상태 관리 로직이 여기에 구현됩니다. Redux에서는 상태 변경을 단순화하기 위해 불변성을 유지하며, 이전 상태를 변경하지 않고 새로운 상태를 반환합니다.
- Dispatch ⇒ 스토어에 액션을 보내는 함수입니다. 액션을 디스패치하면, Redux는 액션과 현재 상태를 리듀서에 전달하여 상태를 업데이트합니다.
    - (부수 효과: 외부의 상태를 변경하는 것 또는 함수로 들어온 인자의 상태를 직접 변경하는 것)
    - (순수 함수: 부수효과가 없는 함수 즉, 어떤 함수에 동일한 인자를 주었을 때항상 같은 값을 리턴하는 함수  + 외부의 상태를 변경하지 않는 함수)
- Redux는 복잡한 상태 관리를 단순화하고, 애플리케이션의 상태를 효율적으로 관리할 수 있도록 도와줍니다. 특히, 대규모 애플리케이션에서 상태 공유와 관리를 용이하게 해주는데, Redux를 사용하는 것 자체만으로 발생하는 부하가 있기 때문에, 애플리케이션 규모에 따라 적용할지 말지는 고민을 해보아야 한다고 이해하고 있습니다.

# Client Side Rendering, Server Side Rendering

- Client Side Rendering ⇒ 렌더링이 클라이언트 쪽에서 일어나는 아키텍쳐입니다. 즉, 서버는 요청을 받으면 클라이언트에 HTML과 JS를 보내주고, 클라이언트가 이를 받아서 렌더링을 시작하는 것입니다. 클라이언트 사이드 렌더링은 서버에서 처리 없이 클라이언트로 바로 보내주기 때문에, 서버가 보내준 HTML과 JS를 모두 다운로드하고 실행까지 완료되기 전에는 사용자가 볼 수 있는게 없습니다.
- Server Side Rendering ⇒ 서버쪽에서 렌더링 준비를 마친 상태로 클라이언트에 전달하는 방식입니다. 즉, 서버에서 리소스를 체크하고, 컴파일하면서 즉시 렌더링 가능한 html 파일을 만들어 클라이언트에 전달하는 것인데, 클라이언트에 전달되는 순간, 이미 렌더링 준비가 되어있던 html 파일이 즉시 렌더링되어 사용자는 화면을 볼 수 있습니다. 단, 이 순간에는 JavaScript까지는 읽히기 전 상태로, 사용자의 조작은 불가능합니다. 이후, 클라이언트가 JS를 다운받는데, 그동안 사용자는 웹 페이지를 조작할 수는 없으나, 이때의 사용자 조작을 기억하고 있다가, 브라우저가 JS까지 성공적으로 컴파일하고 나면, 기억하고 있던 사용자 조작을 실행하고, 웹 페이지는 상호작용이 가능한 상태가 됩니다.
- CSR은 초기 로드 이후의 렌더링은 빠르다, 서버에 요청할 것이 거의 없어서 서버 부담이 적다는 장점이 있고, SSR은 검색 엔진 최적화(SEO)에 좋다, 초기 로딩 속도가 빠르다는 장점이 있습니다.
- 모양이 많은 웹 사이트 일수록 SSR이 필요합니다.

# Single Page Application (SPA)

- React에서는 딱 하나의 html 파일만 존재합니다. App.js 파일에서 볼 수 있듯, JSX 문법을 사용해서 React 요소를 만들고 DOM에 렌더링 시키는 방식으로 뷰를 그립니다. (HTML을 품은 JS === JSX)
- 예전에는 웹 페이지에서 페이지를 보여줄 때, 여러 페이지로 구성이 되어 있었고, 페이지를 로딩할 때마다 서버에서 리소스를 전달받아 렌더링했습니다. 즉, 웹 어플리케이션 뷰를 서버에서 담당했던 것입니다. 하지만, 규모가 커지고 사용자와의 상호작용이 많아짐에 따라, 데이터 정보 전송 과부화로 인한 속도 저하 등 문제점이 생기게 됐습니다. 그래서 요즘은 뷰 렌더링을 서버가 아닌 ‘웹 브라우저’가 담당하도록 조치했습니다. 즉, 예전에는 페이지를 요청할 때마다 서버로 접속하여 새 페이지를 받아왔던 것이고, 때문에 페이지가 매번 새로고침 되었지만, SPA의 경우 서버에서 제공하는 페이지가 한 개입니다. 그래서 Single Page Application 입니다.
- **(왜 굳이 html을 하나만 줄까?)** 페이지를 이동할 때마다 서버에서 주는 다른 html로 화면을 바꾸다 보면, 상태 유지가 어렵고, 바뀌지 않은 부분까지 새로 불러오게 되면서 비효율적이게 됩니다. 따라서, 하나의 html만을 쓰는 아이디어로 구현하게 된 것입니다.
- 사용자에게 보여주는 페이지는 ‘하나’인 것이지만, 브라우저에 입력된 주소 상태에 따라 다양한 화면을 보여줄 수 있습니다. 다른 주소에 다른 화면을 보여주는 것을 Routing이라고 합니다.
- [단점] 앱의 규모가 커지면, JS 파일이 너무 커지면서, 페이지 로딩 시 실제 방문자가 방문하지 않을 수도 있는 페이지들까지 모두 불러오는 SPA의 특성 상 효율적으로 좋지 않은 영향이 있을 수 있습니다. 또한, 검색 엔진 최적화, 크롤러가 페이지 정보를 수집하기에도 적절하지 않아, 페이지 검색이 힘들다고 합니다.

# SPA와 CSR은 같은 말일까?

- 아닙니다. SPA/MPA는 페이지를 하나만 쓰는지, 여러 개를 쓰는지에 차이가 있는 것이고, CSR/SSR은 렌더링을 어디서 하는지에 차이가 있는 것입니다. 즉, 서로 비교 대상이 아닙니다.
- 다만, React 같은 SPA는 처음에만 페이지를 받아오고 이후에는 받아오지 않는데, 이럼에도 데이터가 수정되고 조회되게 하고 싶어서 CSR이라는 방식을 채택한 것입니다. 반대로, MPA는 동적이지 않은 페이지를 상황에 맞게 클라이언트에 뿌려주기 때문에 SSR 방식을 채택한 것입니다.

# Next.js

- SPA인 React에서 SSR을 가능하도록 구현한 프레임워크입니다. Next.js는 모든 페이지를 pre-rendering합니다. 서버에서 각 페이지의 HTML을 미리 생성하고, 생성된 HTML은 최소한의 자바스크립트와 연결됩니다.
- (Next.js가 SSR을 수행하는 방식) Next.js는 SSR을 기반으로 하지만, 페이지가 로드 된 이후에는 React에서 CSR을 이용하는 방식대로 동작합니다. 먼저, 페이지는 서버가 그리고, 라우팅 페이지들을 서버측에서 먼저 로드해줍니다. 페이지가 그려진 이후에 페이지 내부에서, 동적인 데이터들을 패치하는 과정(axios 등)은 CSR 방식을 따릅니다. 이 때, 데이터들은 일단 페이지가 로드 된 이후에, 클라이언트 측에서 다시 렌더링되며 불러와집니다. (그렇기 때문에 이 부분은 SEO에 걸리지 않습니다)

# CDD(Component Driven Development)

- 컴포넌트 주도 개발(CDD)는 컴포넌트를 모듈 단위로 개발하여 UI 구축에 도달하는 개발 및 설계 방법론입니다. 컴포넌트 수준에서 시작해, 페이지나 화면 수준으로 끝나는 것으로 점진적으로 조립해가는 bottom-up 성향을 띕니다.
- 이 방법으로 UI를 구축할 때 직면하게 되는 앱 규모의 복잡성을 해결할 수 있습니다.
    - 컴포넌트 components
    - 컨테이너 containers, 2개 이상 컴포넌트 조합
    - 페이지 pages, 2개 이상 컨테이너 조합

# 컴포넌트 생명주기

- (컴포넌트가 렌더링을 준비하는 순간부터, 페이지에서 사라질 때까지)
- 컴포넌트는 ‘생성’되고, ‘수정’되고, ‘제거’됩니다.
- 생성은 처음으로 컴포넌트를 불러오는 단계입니다. 수정, 즉 업데이트는 클릭, 데이터 입력 등의 사용자의 행동으로 데이터가 바뀌거나, 부모 컴포넌트가 렌더링될 때 업데이트 됩니다. 그리고, 페이지를 이동하거나 사용자의 행동(삭제 버튼 클릭 등)으로 인해 컴포넌트가 사라지면, 제거 단계에 이른 것입니다.

# useCallback

- useCallback은 함수를 ‘메모이제이션’해서 여러 번 만들지 않게 해주는 hook입니다. 즉, 함수를 최적화하기 위한 방법 중 하나인 것입니다. 보동, React.memo와 함께 사용해서 불필요한 렌더링을 방지하기 위해 씁니다. 단, useCallback을 사용한다고 해서 무조건 렌더링 횟수가 줄어드는 것은 아니며, 오히려 무분별한 메모이제이션은 효율에 나쁜 영향을 미칠 수 있습니다. 주로 자식 컴포넌트에게 props로 넘기는 callback 함수를 감싸는 데 쓰입니다.

# Custom Hook

- Custom Hook을 만드는 것은, 자바스크립트 함수에서 반복되는 코드를 효율적으로 관리하는 방법 중 하나입니다. 반복되는 코드를 효율적으로 관리하기 위해 또 다른 함수로 묶어서 사용하곤 하는데요, custom hook은 컴포넌트 내에서 훅을 사용하는 로직을 따로 분리하기 위한 것입니다. (컴포넌트도 훅도 함수)

# Portal

- 리액트 포탈은 “부모 컴포넌트의 DOM 계층 구조 바깥에 있는 DOM node”로, 자식을 렌더링하는 방법 중 하나입니다.
- (리액트 포탈을 사용하는 이유?) 리액트는 부모 컴포넌트가 렌더링 되면, 자식 컴포넌트도 렌더링 되는 Tree 구조로 구성되어 있습니다. 이런 Tree 구조는, 부모-자식 관계를 가지고 있다보니 **DOM 계층 구조에 영향**을 미치게 됩니다. 하지만 리액트 포탈을 사용하면, **독립적인 위치에서 렌더링하기 때문에 편리하게 사용 가능**하다는 특징이 있습니다. 대표적인 예로, 스타일링을 간편히 할 수 있습니다. 즉, 리액트 포탈을 사용하면 스타일링을 간편하게 사용 가능하고, 이런 독립된 스타일링은 유지보수성을 향상시키고 CSS 충돌을 방지하는 효과로 이어집니다.